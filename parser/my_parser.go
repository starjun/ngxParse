package parser

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/tidwall/pretty"
)

type UpsAddress struct {
	Ip_port      string
	Fail_timeout string
	Max_fails    string
	// backup
}

type Upstream struct {
	Name    string
	Address []UpsAddress
}

type AutoGenerated struct {
	UpstreamName    string `json:"UpstreamName"`
	UpstreamServers []struct {
		Address    string   `json:"Address"`
		Flags      []string `json:"Flags"`
		Parameters struct {
			FailTimeout string `json:"fail_timeout"`
			MaxFails    string `json:"max_fails"`
		} `json:"Parameters"`
	} `json:"UpstreamServers"`
	Directives interface{} `json:"Directives"`
}

type Directives struct {
	Block      Block    `json:"Block"`
	Name       string   `json:"Name"`
	Parameters []string `json:"Parameters"`
	Modifier   string   `json:"Modifier,omitempty"`
	Match      string   `json:"Match,omitempty"`
}
type Block struct {
	Directives []Directives `json:"Directives"`
}

type Location struct {
	Match      string
	Modifier   string
	Proxy_pass string
}

type Server struct {
	Server_names []string
	Listers      []string
	Locations    []Location
}

func CHJ_ngx_Parser(_str string) (mm []Upstream, ss []Server, err error) {
	p := NewStringParser(_str)
	c := p.Parse()
	mjson, _ := json.Marshal(c.FindDirectives("upstream"))
	var m []AutoGenerated
	err = json.Unmarshal(mjson, &m)
	if err != nil {
		return
	} else {
		for _, v := range m {
			tmp_m := Upstream{
				Name: v.UpstreamName,
			}
			// fmt.Println(v.UpstreamName)
			for _, vv := range v.UpstreamServers {
				tmp_ups := UpsAddress{
					Ip_port:      vv.Address,
					Fail_timeout: vv.Parameters.FailTimeout,
					Max_fails:    vv.Parameters.MaxFails,
				}

				tmp_m.Address = append(tmp_m.Address, tmp_ups)
			}
			mm = append(mm, tmp_m)
		}
	}

	mjson_block, _ := json.Marshal(c.FindDirectives("server"))
	var m_dir []Directives
	err = json.Unmarshal(mjson_block, &m_dir)
	if err != nil {
		return
	} else {
		for _, v := range m_dir {
			var tmp_s Server
			for _, vv := range v.Block.Directives {
				t := reflect.TypeOf(vv)
				if vv.Name == "listen" {
					tmp_s.Listers = append(tmp_s.Listers, vv.Parameters[0])
				} else if vv.Name == "server_name" {
					tmp_s.Server_names = vv.Parameters
				} else if vv.Name == "location" {
					// fmt.Println("匹配到 location ")
					var tmp_location Location
					if _, ok := t.FieldByName("Modifier"); ok {
						// println("存在")
						tmp_location.Modifier = vv.Modifier
						tmp_location.Match = vv.Match
					} else {
						// println("不存在")
						tmp_location.Modifier = ""
						tmp_location.Match = vv.Match
					}
					if !reflect.DeepEqual(vv.Block.Directives, []Directives{}) {
						for _, vvv := range vv.Block.Directives {
							if vvv.Name == "proxy_pass" {
								tmp_location.Proxy_pass = vvv.Parameters[0]
							}
						}
					}
					tmp_s.Locations = append(tmp_s.Locations, tmp_location)
				}
			}
			ss = append(ss, tmp_s)
		}
	}
	return

}

func Printf_Color(value interface{}) {
	jjjj, err := json.Marshal(value)
	if err != nil {
		fmt.Println(err)
	}
	// fmt.Printf("%s\n", pretty.Pretty(jjjj))
	fmt.Printf("%s\n", pretty.Color(pretty.Pretty(jjjj), pretty.TerminalStyle))
}
